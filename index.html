<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Adresses du public de la 20eme C</title>
    <script src="./javascripts/hull.js"></script>
    <script src="./javascripts/dataGeo.js"></script>
    <script src="./javascripts/fonctions.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-ajax/2.1.0/leaflet.ajax.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script> 
    <script src="https://api.mapbox.com/mapbox.js/plugins/leaflet-geodesy/v0.1.0/leaflet-geodesy.js"></script>
    <link rel="stylesheet" type="text/css" href="./stylesheets/slider.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@0.4.13/docs/examples/libs/leaflet.geometryutil.js"></script>
    <script src="//cdn.amcharts.com/lib/4/core.js"></script>
    <script src="//cdn.amcharts.com/lib/4/charts.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/themes/animated.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-easyprint@2.1.9/dist/bundle.min.js"></script>
    <link rel="stylesheet" type="text/css" href="./stylesheets/tooltip.css">
	  
    <script src="./javascripts/qpv_qva.json"></script>
    <script src="./javascripts/IRIS.json"></script>

</head>
<body>
    <header>
      <h3>Public de la 20ème Chaise - Saisons 2018-19 et 2019-2020 </h3>
        <a href="https://www.la20emechaise.org/" class="button">Site internet du centre social</a>
      </div>
    </header>

	<script>
	function Separateur_Milliers(value) {
    	return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
	};
	</script>
	
    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
<p> - extraction de 902 adresses de Noe <br>
    - récupération des coordonnées des adresses via https://adresse.data.gouv.fr/csv <br>
    - on choisit de travailler au niveau famille et non au niveau individu <br>
    - on va étudier :  <br>
    &nbsp &nbsp &nbsp Partie 1 : la localisation des adresses par rapport aux quartiers prioritaires de la ville (NQPV),  <br>
    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp aux quartiers de veille active (QVA) et aux anciens quartiers de veille (AQV) <br>
    &nbsp &nbsp &nbsp Partie 2 : la répartition des adresses selon le temps de trajet à la 20ème Chaise <br>
    &nbsp &nbsp &nbsp Partie 3 : la répartition des adresses dans les IRIS et les zones d'influence des autres centres sociaux parisiens
</p>

<fieldset style= "border: 1px solid #666;
  border-radius: 8px">
  <legend><b>Vous pouvez filtrer les données selon les critères suivants (cocher les cases pour fixer les critères) et choisir le rayon des
	  cercles d'influence des centres sociaux (saisir le rayon) :</b></legend>
	
<fieldset style= "border: 1px solid #666;
  border-radius: 8px">
<div>
<input type="checkbox" num_cb="1" id ="filtre_type_act" name="type_filtre"/>
<label for="filtre_type_act">Types d'activités auxquelles <b><u>la famille</b></u> s'est inscrite</label><br>
</div>
<div class="radio_1" style="display: none;">
<p><b><u>1- choix des activités</u></b></p>
<script>
const type_act = ['clas','acm','jeunesse','famille','sorties_famille','cartes_blanches','culture','sport','asl','paniers_bio','reveillon','autres'] ;
type_act.forEach(function(element,index)
{
var checkbox = document.createElement('input');
checkbox.type = "checkbox"; 
checkbox.id = "type_act_"+ (index+1) ;
var label = document.createElement('label'); 
label.htmlFor = "type_act_"+ (index+1) ; 
label.appendChild(document.createTextNode(element)); 
document.getElementsByClassName('radio_1')[0].appendChild(checkbox); 
document.getElementsByClassName('radio_1')[0].appendChild(label); 
}) ;
</script>
<p><b><u>2- inscriptions à au moins une des activités sélectionnées OU à l'ensemble des activités sélectionnées</u></b></p>
<div class="choix_ou_et">
<input type="radio" id ="choix_ou" name="choix_ou_et" / checked>
<label for="choix_ou">au moins une des activités</label>
<input type="radio" id ="choix_et" name="choix_ou_et">
<label for="choix_et">toutes les activités</label>
</div>
<p><b><u>3- inscriptions au moins aux activités sélectionnées OU uniquement aux activités sélectionnées</u></b></p>
<div class="choix_aumoins_auplus">
<input type="radio" id ="choix_aumoins" name="choix_aumoins_auplus" / checked>
<label for="choix_aumoins">au moins aux activités sélectionnées</label>
<input type="radio" id ="choix_auplus" name="choix_aumoins_auplus">
<label for="choix_auplus">uniquement aux activités sélectionnées</label>
</div>
</div>
</fieldset>
	
<fieldset style= "border: 1px solid #666;
  border-radius: 8px">
<div>
<input type="checkbox" num_cb="2" id ="filtre_nb_act" name="type_filtre"/>
	<label for="filtre_nb_act">Nombre total d'inscriptions de <b><u>la famille</u></b> aux activités sur la période<br>(placer les 2 curseurs aux nombres minimum et maximum souhaités)</label><br>
</div>
<div class="radio_2" style="display: none;">
<div style="height:100px">
<div style="height:40px">
</div>
<div id="slider">

</div>
</div>
</div>
</fieldset>

<fieldset style= "border: 1px solid #666;
  border-radius: 8px">
<div>
<input type="checkbox" num_cb="3" id ="filtre_benevole" name="type_filtre"/>
<label for="filtre_benevole">Contribution bénévole (au moins un membre de <b><u>la famille</b></u> a été bénévole) </label><br>
</div>
<div class="radio_3" style="display: none;">
<input type="radio" id ="bene_non" name="bene"/ checked>
<label for="bene_non">pas de filtre bénévole</label>
<input type="radio" id ="bene_oui" name="bene"/>
<label for="bene_oui">bénévole sur au moins un type d'activité</label>
</div>
</fieldset>
<fieldset style= "border: 1px solid #666;
  border-radius: 8px">
<div>
<label for="rayon_cercles_influence">choix du rayon des cercles d'influence des centres sociaux (en mètres, 750 mètres correspondent approximativement à un
	trajet de 10 minutes à pied) : </label>
<input type="number"  id ="rayon_cercles_influence" name="saisie" value="750" min="100" max="1500" step="50">
</div>
</fieldset>	
	
</fieldset>


<div>	
<input type="button" id = "bouton_envoi" name="bout" value="Générer l'analyse en fonction des filtres" onClick="envoi_analyse()"
       style="height:50px; width:50%; margin-left:25%; margin-right:25%;margin-top: 0.5cm;margin-bottom: 0.5cm; background-color:#B0C4DE" />
</div>

<!--on place un div de commentaire pour informer l'utilisateur de la requête envoyée et le nombre de données
le texte du div est rempli une fois la requete connue -->
<fieldset style= "border: 1px solid red;
  border-radius: 8px; background-color: #F5B7B1">
  <legend style="color:red"><b>Les résultats ci-dessous sont liés aux filtres suivants :</b></legend>
	
<div id="resume_requete" style="color:red;">
En attente des résultats...
</div>
</fieldset>

<h3><a name="synthèse" class="anchor" ><span class="octicon octicon-link"></span>Synthèse des résultats (vue détaillée dans les cartes ci-dessous)</a></h3>

<!-- on génère les graphiques en synthèse-->
<style>
#graphe_qpv {
  display: inline-block;
  width: 30%;
  height: 300px;
}
#graphe_trajet {
  display: inline-block;
  width: 30%;
  height: 300px;
}
#graphe_influence {
  display: inline-block;  
  width: 30%;
  height: 300px;
}
</style>
		
<div class="graphes" id="graphe_qpv"></div>
<div class="graphes" id="graphe_trajet"></div>
<div class="graphes" id="graphe_influence"></div>
<div>
Vous pouvez survoler les secteurs des graphiques pour visualiser le nombre d'adresses recensées
</div>
<!--on ajoute des listeners qui font apparaître-disparaître les choix possibles pour chaque filtre-->
<script>
var cases = document.querySelectorAll('input[name="type_filtre"]');
cases.forEach(function(checkbox) {
  checkbox.addEventListener('change', function() {
    if (checkbox.checked === true)    
    {for (i=0 ; i < document.getElementsByClassName('radio_'+ this.getAttribute("num_cb")).length ; i++)
	{document.getElementsByClassName('radio_'+ this.getAttribute("num_cb"))[i].style = "display : inline" ;} ;
    }
    else
    {
    for (i=0 ; i < document.getElementsByClassName('radio_'+ this.getAttribute("num_cb")).length ; i++)
    	{document.getElementsByClassName('radio_'+ this.getAttribute("num_cb"))[i].style = "display : none" ;} ;
	// on remet les choix de filtre à zéro si on désélectionne un filtre
	// on doit gérer les cas de figures car on a des contrôles différents
    switch(this.getAttribute("num_cb"))
    	{
		case '1':
	        type_act.forEach(function(element,index)
			{
			document.getElementById("type_act_"+ (index+1)).checked = false ;
			}) ;
		document.getElementById("choix_ou").checked = true ;
		document.getElementById("choix_aumoins").checked = true ;
		break ;
		case '2':
		document.getElementById("slider").noUiSlider.reset() ;
		break ;
		case '3':
		document.getElementById("bene_non").checked = true ;
		break ;
	}
		 

    }	    
  })
});


</script>

<!-- script qui recherche le nombre minimum et maximum d'activité puis crée le slider -->
<script>

var diff_nb_act = data.map(function(element) {
    return element.nb_tot_act ;
    });
var unique = diff_nb_act.filter(function(value, index, self) {
  return self.indexOf(value) === index;
});
unique.sort(function(a, b) {
  return a - b;}) ;

var rangers = {}
for (i = 0; i < unique.length; ++i) {
  var pourcent = Math.ceil((100/unique.length) * i)
  if ( i == 0 ) { rangers['min'] = unique[0]; }
  else if ( i < unique.length-1 ) { rangers[pourcent +'%'] = [ unique[i],  unique[i+1] - unique[i] ] ;}
  else if ( i == unique.length-1 ) { rangers['max'] = [unique[unique.length-1]]; }
}
var slider = document.getElementById('slider');
noUiSlider.create(slider, {
    start: [unique[0], unique[unique.length-1]],
    connect: true,
    tooltips: [{
        to: (v) => parseFloat(v).toFixed(0),
        from: (v) => parseFloat(v).toFixed(0)
    }, {
        to: (v) => parseFloat(v).toFixed(0),
        from: (v) => parseFloat(v).toFixed(0)
    }],
    range: rangers,
    pips: {
        mode: 'steps',
        density: 3
          }
});
</script>

<script>
var tableau_sortie = [] ;
var string_filtre = '';
var string_comment_act = '';
var string_comment_nb_act = '';
var string_comment_bene = '';	
// fonction appelée par le clique du bouton
// on stocke tous les filtres saisis par l'utilisateur avant de rafraichier la page
	
function envoi_analyse() {
document.getElementById('bouton_envoi').value = "Génération de l'analyse en cours..." ;
document.getElementById('bouton_envoi').style.backgroundColor = "#FF8C00" ;
localStorage.setItem("btn_click", true) ;
// on récupère le et/ou et le au moins/uniquement
var lien_act_select ;
var val_autres_act ;
if (document.getElementById('choix_ou').checked)
	{
	lien_act_select = ' || ' ;
	}
        else
	{
	lien_act_select = ' && ' ;
	}
if (document.getElementById('choix_aumoins').checked)
	{
	val_autres_act = '>= 0' ;
	}
        else
	{
	val_autres_act = '== 0' ;
	}
// on traite tout d'abord le filtre pour les activités sélectionnées pour avoir les bons opérateurs logiques
for (let i=0 ; i < type_act.length ; i++)
{
if (document.getElementById('type_act_' + (i+1)).checked)
	{if (string_filtre == '')
		{
		string_filtre += 'element.' + type_act[i] + ' >0 ' ;
		string_comment_act += '- Inscriptions' + ' à' + (lien_act_select === ' && ' ? " chacune des activités suivantes : " : " l'une des activités suivantes : ")
			+ type_act[i];
		}
	 	else
		{
		string_filtre += lien_act_select + 'element.' + type_act[i] + ' >0 ' ;
		if (lien_act_select == ' || ')
			{
			string_comment_act += ' ou ' + type_act[i] ;
			}
			else
			{
			string_comment_act += ' et ' + type_act[i] ;
			}	
		}			
	}
}

if (string_comment_act != '')
{
string_comment_act += (val_autres_act === '== 0' ? " mais aucune autre activité." : " et éventuellement d'autres activités.") ;
}
	
// si la chaine de filtre est non vide, on l'entoure de parenthèses pour isoler les éventuels liens logiques OR
if (string_filtre != '')
{string_filtre = '(' + string_filtre + ')' ;}

// on traite ensuite les activités non sélectionnées
for (let i=0 ; i < type_act.length ; i++)
{
if (!document.getElementById('type_act_' + (i+1)).checked)
	{
	if (val_autres_act == '== 0')
		{
		string_filtre += ' && ' + 'element.' + type_act[i] + ' ==0 ' ;
		}
	}
}
// on traite maintenant le nombre d'activités
if (string_filtre == '')
		{
		string_filtre += 'element.nb_tot_act' + ' >= ' + parseInt(slider.noUiSlider.get()[0]) ;
		string_filtre += ' && ' ;
		string_filtre += 'element.nb_tot_act' + ' <= ' + parseInt(slider.noUiSlider.get()[1]) ;	
		}
	 	else
		{
		string_filtre += ' && ' ;
		string_filtre += 'element.nb_tot_act' + ' >= ' + parseInt(slider.noUiSlider.get()[0]) ;
		string_filtre += ' && ' ;
		string_filtre += 'element.nb_tot_act' + ' <= ' + parseInt(slider.noUiSlider.get()[1]) ;	
		}

string_comment_nb_act = '- Nombre d\'inscriptions total de la famille compris entre ' + parseInt(slider.noUiSlider.get()[0]) + ' et ' + parseInt(slider.noUiSlider.get()[1]) + '.' ;

// on traite maintenant le filtre bénévoles
if (document.getElementById('bene_oui').checked)	
{if (string_filtre == '')
		{
		string_filtre += 'element.bene' + ' > ' + '0' ;	
		}
	 	else
		{
		string_filtre += ' && ' ;
		string_filtre += 'element.bene' + ' > ' + '0' ;
		}
string_comment_bene = '- Au moins un membre de la famille bénévole.' ; 
}
else
{
string_comment_bene = '- Pas de filtre bénévole.' ;
}
console.log(string_filtre) ;
localStorage.setItem("filtre_final", string_filtre ) ;
localStorage.setItem("comment_final_act", string_comment_act ) ;
localStorage.setItem("comment_final_nb_act", string_comment_nb_act ) ;
localStorage.setItem("comment_final_bene", string_comment_bene ) ;
localStorage.setItem("rayon_cercles",JSON.stringify(document.getElementById("rayon_cercles_influence").value)) ;
// après toute la récupération, on rafraichit la page
window.location.reload();
};
     
</script>

<script>
var tableau_test = [] ;
	
function chargement_donnees()
{
if (localStorage.getItem("filtre_final") === null)
{
tableau_test = data ;
document.getElementById('resume_requete').innerHTML = '- Aucun filtre.'
	+ '<br>' + '- Nombre de familles obtenu : ' + tableau_test.length
	+ '<br>' + ' - Rayon des cercles d\'influence des centres sociaux : ' + '750' + ' mètres';
}
else if (localStorage.getItem("filtre_final").length == 0)
{
tableau_test = data ;
document.getElementById('resume_requete').innerHTML = '- Aucun filtre.'
	+ '<br>' + '- Nombre de familles obtenu : ' + tableau_test.length
	+ '<br>' + ' - Rayon des cercles d\'influence des centres sociaux : ' + '750' + ' mètres';
}
else
{
tableau_test = data.filter(function(element) {
    return (eval(localStorage.getItem("filtre_final")));});
document.getElementById('resume_requete').innerHTML = (localStorage.getItem("comment_final_act") === '' ? " - Aucun filtre sur les activités." : localStorage.getItem("comment_final_act"))
	+ '<br>' + localStorage.getItem("comment_final_nb_act") + '<br>' + localStorage.getItem("comment_final_bene")
	+ '<br>' + '- Nombre de familles obtenu : ' + tableau_test.length
	+ '<br>' + ' - Rayon des cercles d\'influence des centres sociaux : ' + JSON.parse(localStorage.getItem("rayon_cercles")) + ' mètres' ;
}
// on génère un test sur la longueur du tableau
// si elle est nulle, on ne génère aucune carte

document.getElementById('resume_requete').style.color = 'red' ;
// on gère le filtrage des données en amont de tous les exemples... si l'envoi de vient pas du bouton
if (JSON.parse(localStorage.getItem("btn_click")) === false)
	{  
	tableau_sortie = data ;
	}
	else
	{
// on place les filtres fonction de ce qui a été sélectionné par l'utilisateur
	tableau_sortie = tableau_test ;
	}
	
}
	
</script>

<!-- Exemple 1 -->
<h3><a name="ex1" class="anchor" ><span class="octicon octicon-link"></span>QPV, QVA et AQV</a></h3>

<p> <i> <font size = "2">
       - récupération des polygones définissant les quartiers prioritaires via une source de type GeoJSON <br>
       - recherche des adresses relevant d'un NQPV (frontière noire), QVA (frontière jaune) ou AQV (frontière violette) via fonction turf.js PointsWithinPolygon <br> </i> </font>
       - survoler les quartiers prioritaires pour voir apparaître le nom de la zone
</p>

<p>
  <div id="map_1" style="width: 100%; height: 560px"></div>
  <script>
	  
 function exemple1() {
    var map_1 = L.map('map_1',{ scrollWheelZoom: false }).setView([48.864891,2.389828], 14);
  	 
    L.easyPrint({
	title: 'Imprimer',
	position: 'topleft',
	sizeModes: ['Current', 'A4Landscape', 'A4Portrait'],
      	filename: 'myMap',
      	exportOnly: true,
      	hideControlContainer: true
	}).addTo(map_1);
	 
    tableau_sortie.map( adresse => {
    let properties = {
   "lng": adresse.lng,
   "lat": adresse.lat
    };
    return properties;
    });
	 
    var PS = tableau_sortie;
   
    //var Res_Max = Math.max.apply(null,data.map(function(o){return o.duree_pied;}));
    //var Res_Min = Math.min.apply(null,data.map(function(o){return o.duree_pied;}));
  
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map_1);
  
  var Layer_NQPV = L.geoJson(geojsonFeature,  {filter : function(feature) {
        return feature.properties.c_nat_qpv == 'NQPV'}, style : function(feature) {
		return {color: 'black', weight: 2.0, opacity : 0.7, fillOpacity : 0.2}}}
);

  var Layer_QVA = L.geoJson(geojsonFeature,  {filter : function(feature) {
        return feature.properties.c_nat_qpv == 'QVA'}, style : function(feature) {
		return {color: 'yellow', weight : 2.0, opacity : 0.7, fillOpacity : 0.2}}}
);

  var Layer_AQV = L.geoJson(geojsonFeature,  {filter : function(feature) {
        return feature.properties.c_nat_qpv == 'AQV'}, style : function(feature) {
		return {color: 'purple', weight : 2.0, opacity : 0.7, fillOpacity : 0.2}}}
);
  
 Layer_NQPV.addTo(map_1);
 Layer_QVA.addTo(map_1);
 Layer_AQV.addTo(map_1);

map_1.eachLayer(function (layer) {
    // on exclut le layer du fond de carte via un contrôle
    if(layer.hasOwnProperty('feature'))
    {
     layer.bindPopup('<h3>'+layer.feature.properties.c_nat_qpv + ' : ' + layer.feature.properties.l_nqpv + '</h3>');
     layer.on('mouseover', function (e) {this.openPopup();});
     layer.on('mouseout', function (e) {this.closePopup();});
    }
                                   });


// on crée un array avec toutes les adresses source au format turf
var adresses_turf = [];
PS.forEach(function(element)
{adresses_turf.push([element.lng, element.lat]);}
)

// on passe à la recherche d'intersection des adresses avec les zones prioritaire
// et à la création des points de couleur dépendant du résultat

  var layer_adresses_NQPV = L.layerGroup().addTo(map_1);
  var layer_adresses_QVA = L.layerGroup().addTo(map_1);
  var layer_adresses_AQV = L.layerGroup().addTo(map_1);

function inside(points,zone)
{return turf.pointsWithinPolygon(
 turf.points(points), 
 zone.toGeoJSON()
  );}
	 
// on génère dans un premier temps tous les marqueurs qu'on recouvrera ensuite selon les zones le cas échéant
PS.forEach(function(latlng){
        L.circleMarker(latlng, {radius: 2, color : 'blue'}).addTo(map_1);
                     }
	           );
   // var markers_adresses = {'markers': layer_adresses};
   // L.control.layers(null, markers_adresses).addTo(map_1);

  
var adresses_NQPV = inside(adresses_turf,Layer_NQPV);

for (let i=0 ; i < adresses_NQPV.features.length; i++)
{
var coords = [];
coords[0] = adresses_NQPV.features[i].geometry.coordinates[1];
coords[1] = adresses_NQPV.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'black'}).addTo(map_1);
};

var adresses_QVA = inside(adresses_turf,Layer_QVA);

for (let i=0 ; i < adresses_QVA.features.length; i++)
{
var coords = [];
coords[0] = adresses_QVA.features[i].geometry.coordinates[1];
coords[1] = adresses_QVA.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'yellow'}).addTo(map_1);
};

var adresses_AQV = inside(adresses_turf,Layer_AQV);

for (let i=0 ; i < adresses_AQV.features.length; i++)
{
var coords = [];
coords[0] = adresses_AQV.features[i].geometry.coordinates[1];
coords[1] = adresses_AQV.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'purple'}).addTo(map_1);
};

 document.getElementById("comment_1").innerHTML = adresses_NQPV.features.length +
	 ' adresses relèvent d\'un quartier NQPV (en noir) '
	 + (adresses_turf.length === 0 ? '' : '(' + parseFloat(adresses_NQPV.features.length / adresses_turf.length * 100).toFixed(0)+ ' %' + ')') + '<br/>' +
	 adresses_QVA.features.length +
	 ' adresses relèvent d\'un quartier QVA (en jaune) '
	  + (adresses_turf.length === 0 ? '' : '(' + parseFloat(adresses_QVA.features.length / adresses_turf.length * 100).toFixed(0)+ ' %' + ')') + '<br/>' +
	 adresses_AQV.features.length +
	 ' adresses relèvent d\'un quartier AQV (en violet) '
	  + (adresses_turf.length === 0 ? '' : '(' + parseFloat(adresses_AQV.features.length / adresses_turf.length * 100).toFixed(0)+ ' %' + ')') + '<br/>' +
	 (adresses_turf.length - adresses_NQPV.features.length
	- adresses_QVA.features.length - adresses_AQV.features.length) + ' n\'en relèvent pas (en bleu) '
	  + (adresses_turf.length === 0 ? '' : '(' + parseFloat((adresses_turf.length - adresses_NQPV.features.length
	- adresses_QVA.features.length - adresses_AQV.features.length) / adresses_turf.length * 100).toFixed(0)+ ' %' + ')')

// génération du graphique de synthèse
am4core.ready(function() {

// Themes begin
am4core.useTheme(am4themes_animated);
// Themes end

var chart = am4core.create("graphe_qpv", am4charts.PieChart);
chart.hiddenState.properties.opacity = 0; // this creates initial fade-in

chart.data = [
  {
    type_quartier: "NQPV",
    value: adresses_NQPV.features.length,
    labelColor: new am4core.color('black')
  },
  {
    type_quartier: "QVA",
    value: adresses_QVA.features.length,
    labelColor: new am4core.color('#ffd700')
  },
  {
    type_quartier: "AQV",
    value: adresses_AQV.features.length,
    labelColor: new am4core.color('purple')
  },
  {
    type_quartier: "Autres",
    value: (adresses_turf.length - adresses_NQPV.features.length
	- adresses_QVA.features.length - adresses_AQV.features.length),
    labelColor: new am4core.color('blue')
  }
];
chart.radius = am4core.percent(50);
chart.innerRadius = am4core.percent(35);
chart.startAngle = 180;
chart.endAngle = 360;  

var series = chart.series.push(new am4charts.PieSeries());
series.dataFields.value = "value";
series.dataFields.category = "type_quartier";

series.slices.template.cornerRadius = 5;
series.slices.template.innerCornerRadius = 5;
series.slices.template.draggable = true;
series.slices.template.inert = true;
series.alignLabels = false;

series.hiddenState.properties.startAngle = 90;
series.hiddenState.properties.endAngle = 90;
series.labels.template.fontSize = 11;
series.labels.template.maxWidth = 60;
series.labels.template.wrap = true;
series.colors.list = [
    new am4core.color('black'),
    new am4core.color('#ffd700'),
    new am4core.color('purple'),
    new am4core.color('blue')
];
series.labels.template.text = "{category} {value.percent.formatNumber('#.')}%";
chart.series.getIndex(0).labels.template.propertyFields.fill = "labelColor";

chart.exporting.menu = new am4core.ExportMenu();
chart.exporting.menu.align = "left";
chart.exporting.menu.verticalAlign = "top";
	
}); // end am4core.ready()

 }
</script>
</p>
<p id="comment_1"></p>	      
<!-- FIN: Exemple 1 -->

<!-- Exemple 2 -->
<h3><a name="ex2" class="anchor" ><span class="octicon octicon-link"></span>Temps de trajet à pied</a></h3>

<p> <i> - récupération des temps de trajet et distance (à pied, en voiture, en transports en commun) <br>
         à la 20ème Chaise par Google Map API <br>
 <s>    - détermination des enveloppes convexes(-concaves) par algorithme externe </s> &nbsp (laissé en suspens car non adapté aux petits groupes de points asymétriques) <br>
        - détermination des cercles correspondant à chaque zone (certains points ne sont pas dans leur cercle de couleur dans le cas où la distance à vol d'oiseau s'éloigne
	du temps calculé par Google Map API pour se rendre à pied à la 20ème Chaise) </i>
</p>
	      
	      
<p>
  <div id="map_2" style="width: 100%; height: 560px"></div>
  <script>
 function exemple2() {
    var map_2 = L.map('map_2',{ scrollWheelZoom: false }).setView([48.864891,2.389828], 14);
  	 
    L.easyPrint({
	title: 'Imprimer',
	position: 'topleft',
	sizeModes: ['Current', 'A4Landscape', 'A4Portrait'],
      	filename: 'myMap',
      	exportOnly: true,
      	hideControlContainer: true
	}).addTo(map_2);
	 
    var bornes = [0,5,10,15,30,10000];
    var key = 'duree_pieds';

    filtrage_num(tableau_sortie,key);
    
    var nb_adresses_sans_donnees_googleMAPAPI = tableau_sortie.length - filtre_num.length ;
    document.getElementById("comment_2").innerHTML = nb_adresses_sans_donnees_googleMAPAPI + ' adresses sans durée de trajet fournie par Google Map API' + '<br>' ;
    decoupe(filtre_num,'duree_pieds', bornes);
    
    tableau_filtre.forEach(function(element){
    element.map( adresse => {
    let properties = {
   "lng": adresse.lng,
   "lat": adresse.lat
    };
    return properties;
    });
    });
    
	 
    var PS = tableau_filtre;
   
    //var Res_Max = Math.max.apply(null,data.map(function(o){return o.duree_pied;}));
    //var Res_Min = Math.min.apply(null,data.map(function(o){return o.duree_pied;}));
  
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map_2);
    
    var points = new Array();
    var poly = new Array();
    var surface = new Array();
    var color = ['blue','green','yellow','orange','red'];
    var color_fr = ['bleu','vert','jaune','orange','rouge',];
    var convexite = [1.000,1.000,1.000,1.000,1.000];
	 
    PS.forEach(function(element)
    {
    element.forEach(function(latlng)
		    {L.circleMarker(latlng, {radius: 2, color : color[PS.indexOf(element)]}).addTo(map_2);});

    // on ajoute un test sur la longueur de la chaine
    // elle doit être au moins égale à 2 pour générer un polygone sans erreur
    if (element.length < 0)
    {
    points[points.length]= hull(element, convexite[points.length], ['.lng', '.lat']);
    var points_poly = [];
    
    for (let i = 0 ; i < points.length  ; i++) { points_poly[i] = points[points.length - i - 1]; };
    
    poly[poly.length] = L.polygon(points_poly, {weight: 2, color : color[poly.length], fillopacity : 0.9});
    surface[surface.length] = L.GeometryUtil.geodesicArea(poly[surface.length].getLatLngs()[0]);
    }
    else
    // on est dans le cas où on génère des cercles plutôt que des enveloppes convexes
    {
    
    // on développe une autre approche via la construction du plus grand cercle contenant les points
    var rayon_max = 0 ;
    var adresse_from = L.latLng(48.864891,2.389828) ;
    element.forEach(function(latlng)
    	{
    	var adresse_to = L.latLng(latlng.lat,latlng.lng) ;
    	rayon_max = Math.max(rayon_max, adresse_from.distanceTo(adresse_to)) ;
        }
		   )
	    
    var circle = L.circle([48.864891,2.389828], {weight: 2, color : color[poly.length], fillOpacity : 0.0, radius: rayon_max}).addTo(map_2);
		}
    poly[poly.length] = [] ;
    surface[surface.length] = 0 ;
	    
    });
	 
// on insère les polygones dans le sens inverse pour avoir une frontière intérieure de la bonne couleur
    for (let i = points.length-1 ; i >= 0  ; i--) {
    if (poly[i].getLatLngs().length > 0)
    {
    poly[i].addTo(map_2);
    }
    else
    // cas où nombre de points égal à 0
    {
    
    }
    };
    
    // on calcule le nombre total de points pour générer les pourcentages
    var nb_total_points = 0 ;
    PS.forEach(function(element)
    {
    nb_total_points += PS[PS.indexOf(element)].length ;
    }) ;
    
    color_fr.forEach(function(element){
    var texte_zone ;
    texte_zone = ( (color_fr.indexOf(element) == 0) ? 'à moins de ' + bornes[color_fr.indexOf(element)+1] : (color_fr.indexOf(element) < color_fr.length - 1) ? 'entre ' + bornes[color_fr.indexOf(element)] + ' et ' + bornes[color_fr.indexOf(element)+1] : 'à plus de ' + bornes[color_fr.indexOf(element)]) ;
    var superficie ;
    superficie = Separateur_Milliers(Math.round(surface[color_fr.indexOf(element)])) +' mètres carrés' ;
    document.getElementById("comment_2").innerHTML = document.getElementById("comment_2").innerHTML + PS[color_fr.indexOf(element)].length + ' adresses '
	    + 'en ' + color_fr[color_fr.indexOf(element)] + ' sont dans une zone qui se trouve '
	    + texte_zone  + ' minutes de la 20ème Chaise '
	    + (nb_total_points === 0 ? '' : '(' + parseFloat(PS[color_fr.indexOf(element)].length / nb_total_points * 100).toFixed(0)+ ' %' + ')') 
	    + '<br/>';
    });

// génération du graphique de synthèse
am4core.ready(function() {

// Themes begin
am4core.useTheme(am4themes_animated);
// Themes end

var chart = am4core.create("graphe_trajet", am4charts.PieChart);
chart.hiddenState.properties.opacity = 0; // this creates initial fade-in

chart.data = [
  {
    zone: "- de 5 min",
    value: PS[0].length,
    labelColor: new am4core.color('blue')
  },
  {
    zone: "entre 5 et 10 min",
    value: PS[1].length,
    labelColor: new am4core.color('green')
  },
  {
    zone: "entre 10 et 15 min",
    value: PS[2].length,
    labelColor: new am4core.color('#ffd700')
  },
  {
    zone: "entre 15 et 30 min",
    value: PS[3].length,
    labelColor: new am4core.color('orange')
  },
  {
    zone: "+ de 30 min",
    value: PS[4].length,
    labelColor: new am4core.color('red')
  }
];
chart.radius = am4core.percent(50);
chart.innerRadius = am4core.percent(35);
chart.startAngle = 180;
chart.endAngle = 360;  

var series = chart.series.push(new am4charts.PieSeries());
series.dataFields.value = "value";
series.dataFields.category = "zone";

series.slices.template.cornerRadius = 5;
series.slices.template.innerCornerRadius = 5;
series.slices.template.draggable = true;
series.slices.template.inert = true;
series.alignLabels = false;

series.hiddenState.properties.startAngle = 90;
series.hiddenState.properties.endAngle = 90;
series.labels.template.fontSize = 11;
series.labels.template.maxWidth = 60;
series.labels.template.wrap = true;
series.colors.list = [
    new am4core.color('blue'),
    new am4core.color('green'),
    new am4core.color('#ffd700'),
    new am4core.color('orange'),
    new am4core.color('red')
];
series.labels.template.text = "{category} {value.percent.formatNumber('#.')}%";
chart.series.getIndex(0).labels.template.propertyFields.fill = "labelColor";

chart.exporting.menu = new am4core.ExportMenu();
chart.exporting.menu.align = "left";
chart.exporting.menu.verticalAlign = "top";

}); // end am4core.ready()
   
	 
  }
  </script>
</p>
<p id="comment_2"></p>
<!-- FIN: Exemple 2 -->

<!-- Exemple 3 -->
<h3><a name="ex3" class="anchor" ><span class="octicon octicon-link"></span>IRIS et zones d'influence des centres sociaux parisiens</a></h3>

<p><I> - récupération des polygones définissant les IRIS via une source de type GeoJSON <br>
       - on exclut les adresses relevant de la zone de première influence de la 20ème Chaise (liste d'IRIS) (zone en fond bleu)  <br>
       - les zones d'influence des centres sociaux parisiens sont définies par un rayon de 750 mètres par défaut si l'utilisateur ne saisit pas un autre rayon<br>
       - la réunion des cercles d'influence apparaît en mauve ainsi que les points correspondants <br>
       - recherche des adresses relevant d'une zone d'influence des autres CS via fonction turf.js PointsWithinPolygon <br> </i>
       - survoler les zones d'IRIS pour voir apparaître le numéro et le nom de l'IRIS
       - survoler les points rouges pour voir apparaître le nom du centre social concerné
</p>

<p>
  <div id="map_3" style="width: 100%; height: 560px"></div>
  <script>
 function exemple3() {
    var map_3 = L.map('map_3',{ scrollWheelZoom: false }).setView([48.864891,2.389828], 14);
  	 
    L.easyPrint({
	title: 'Imprimer',
	position: 'topleft',
	sizeModes: ['Current', 'A4Landscape', 'A4Portrait'],
      	filename: 'myMap',
      	exportOnly: true,
      	hideControlContainer: true
	}).addTo(map_3);
  
    tableau_sortie.map( adresse => {
    let properties = {
   "lng": adresse.lng,
   "lat": adresse.lat
    };
    return properties;
    });
	 
    var PS = tableau_sortie;
  
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map_3);
 
    var layer_adresses = L.layerGroup().addTo(map_3);
    PS.forEach(
    function(latlng) {
           layer_adresses.addLayer(L.circleMarker(latlng, {radius: 2, color : 'green'}).addTo(map_3));
    });
    var markers_adresses = {'markers': layer_adresses};
   // L.control.layers(null, markers_adresses).addTo(map_3);

 
    
   
   var PS = centres_sociaux;
 
    var layer_adresses_CS = L.layerGroup()

// fonction qui génère l'union de polygones
function unify(polyList,color) {
  for (var i = 0; i < polyList.length; ++i) {
    if (i == 0) {
      var unionTemp = polyList[i].toGeoJSON();
    } else {    
      unionTemp = turf.union(unionTemp, polyList[i].toGeoJSON());
    }
  }
  return L.geoJson(unionTemp, {style: {color: color, weight: 1.0, opacity : 0.8, fill : true, fillColor : color , fillOpacity : 0.2}});
}


    var layer_cercles_CS = L.layerGroup().addTo(map_3);
    var radius = JSON.parse(localStorage.getItem("rayon_cercles")) ;
    var opts = {parts: 144, fill : 'blue' , fillcolor : 'blue', fillOpacity : 0.9};

var Layer_ZI_20C = L.geoJson(iris, {filter: Filtre_influence_20C, style:  {color: 'black',weight: 1.5, opacity : 0.7, fill : true, fillColor : 'orange', fillOpacity : 0.5}}).addTo(map_3);
	 
function Filtre_influence_20C(feature) {
  if ((feature.properties.C_IR >= 751207906 && feature.properties.C_IR <= 751207910)) return true
}
var ZI_20C = unify(Layer_ZI_20C.getLayers(),'blue')
Layer_ZI_20C.clearLayers();
ZI_20C.addTo(Layer_ZI_20C);

// on ajoute des éléments CSS pour générer des tooltips sur mesure pour les CS

var TooltipClass = {
  'className': 'class-tooltip'
}
	 
    PS.forEach(
    function(element) {
	if ( element.nom_centre_social != 'La 20eme Chaise') {
        layer_adresses_CS.addLayer(L.circleMarker([element.lat, element.lng], {radius: 4, color : 'red'}).bindTooltip(element.nom_centre_social,{'className': 'class-tooltip', permanent: false, color : 'red', opacity: 0.7, fillColor : 'red', fillOpacity : 0.3}));
	}
    });
	 
// on crée le layer des cercles d'influence des autres CS
layer_adresses_CS.eachLayer(function(layer)
{ 
 var Test = LGeo.circle(layer.getLatLng(), radius, opts);
 var poly = turf.difference(turf.polygon(Test.toGeoJSON().geometry.coordinates),turf.polygon(ZI_20C.toGeoJSON().features[0].geometry.coordinates)) ;

// attention, avec Firefox et Edge, poly est null si aucune intersection !!
if (poly == null)
{poly = turf.polygon(Test.toGeoJSON().geometry.coordinates) ;}
// on doit gérer le cas où la surface différence est un polygone à trou(s) !!
// attention également au cas des multipolygones !!

// on teste le cas de multipolygones et on compte dans ce cas le nombre de polygones
var nb_poly ;
if (poly.geometry.type == 'Polygon')
{ // cas d'un polygone unique, éventuellement à trous
var lng_lat_poly = [];
for (i=0 ; i < poly.geometry.coordinates.length ; i++)
	{var lng_lat_tmp = [];
 	// on doit inverser les coordonnées de poly issue de turf
 	for (j=0 ; j < poly.geometry.coordinates[i].length ; j++)
 		{
		var lng_lat = [poly.geometry.coordinates[i][j][1], poly.geometry.coordinates[i][j][0]];
		lng_lat_tmp.push(lng_lat);
		}
	lng_lat_poly[i] = lng_lat_tmp;
	}
}
else
{ // cas d'un multipolygone : on doit aller opérer sur chacun des polygones, éventuellement à trous, chaque élément du tableau de coordonnées est un polygone
  // k est le nombre de polygones, i est le nombre de composants de chaque polygones, j est le nombre de coordonnées de chaque composant
var lng_lat_poly = [];
for (k=0 ; k < poly.geometry.coordinates.length ; k++)
	{ // boucle sur chaque polygone : ici, on a un array de dimension 1 si poly simple, de dimension >1 si poly à trous
	var composant_lng_lat_poly = [] ;
	for (i=0 ; i < poly.geometry.coordinates[k].length ; i++)
	// on boucle sur la dimension du poly simple ou à trous
		{var lng_lat_tmp = [];
 	// on doit inverser les coordonnées de poly issue de turf
 		for (j=0 ; j < poly.geometry.coordinates[k][i].length ; j++)
 			{
			var lng_lat = [poly.geometry.coordinates[k][i][j][1], poly.geometry.coordinates[k][i][j][0]];
			lng_lat_tmp.push(lng_lat);
			}
		composant_lng_lat_poly[i] = lng_lat_tmp;
		}
	lng_lat_poly[k] = composant_lng_lat_poly ;
	
	}
}

var cercle_mange = new L.Polygon(lng_lat_poly, {style: {weight: 5.0, color : 'black',  opacity : 0.8, fill : true, fillColor : 'black', fillOpacity : 1.0}});
console.log(cercle_mange) ;
cercle_mange.addTo(layer_cercles_CS) ;
// fin de la boucle sur chaque layer
});
	 
// on crée la zone unique réunion des cercles pour faciliter le calcul des adresses en faisant partie
// on prend la différence avec ces cercles et la zone d'influence de la 20ème Chaise
 var circleUnion = unify(layer_cercles_CS.getLayers(),'purple');
 console.log(circleUnion) ;
 layer_cercles_CS.clearLayers();
 circleUnion.addTo(layer_cercles_CS);	 

// on recherche les adresses dans la zone globale circleUnion
	 
var points_turf = [];
layer_adresses.eachLayer(function(element)
{
var lnglat = [element._latlng.lng, element._latlng.lat];
points_turf.push(lnglat);
}
)


// identification des points dans zone 20eme Chaise
var inside_20C = 
turf.pointsWithinPolygon(
 turf.points(points_turf), 
 ZI_20C.toGeoJSON()
  );
  
for (let i=0 ; i < inside_20C.features.length; i++)
{
var coords = [];
coords[0] = inside_20C.features[i].geometry.coordinates[1];
coords[1] = inside_20C.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'blue'}).addTo(map_3);
};

// identification des points hors zone 20eme Chaise dans zone influence autres CS
var inside = 
turf.pointsWithinPolygon(
 turf.points(points_turf), 
 circleUnion.toGeoJSON()
  );
  
for (let i=0 ; i < inside.features.length; i++)
{
var coords = [];
coords[0] = inside.features[i].geometry.coordinates[1];
coords[1] = inside.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'purple'}).addTo(map_3);
};

 var Layer_IRIS = L.geoJson(iris, { style:  {color: 'black', weight: 1.0, opacity : 0.7, fillColor : 'white', fillOpacity : 0.0}}).bindTooltip(function (layer) {
    return 'IRIS' + '<br/>' + layer.feature.properties.C_IR + ' : ' + layer.feature.properties.L_IR; //merely sets the tooltip text
 }, {permanent: false, opacity: 0.8}  //then add your options
 ).addTo(map_3);

layer_adresses_CS.addTo(map_3);

 document.getElementById("comment_3").innerHTML = inside_20C.features.length +
	 ' sont dans la zone d\'influence de la 20ème Chaise '
	  + (layer_adresses.getLayers().length === 0 ? '' : '(' + parseFloat(inside_20C.features.length / layer_adresses.getLayers().length * 100).toFixed(0)+ ' %' + ')')
	  + '<br/>' +
	 inside.features.length +
	 ' sont dans une zone d\'influence d\'un autre centre social '
	 + (layer_adresses.getLayers().length === 0 ? '' : '(' + parseFloat(inside.features.length / layer_adresses.getLayers().length * 100).toFixed(0)+ ' %' + ')') 
	 + '<br/>' +
	 (layer_adresses.getLayers().length - inside_20C.features.length - inside.features.length) + ' sont hors zones d\'influence '
	 + (layer_adresses.getLayers().length === 0 ? '' : '(' + parseFloat((layer_adresses.getLayers().length - inside_20C.features.length - inside.features.length) / layer_adresses.getLayers().length * 100).toFixed(0)+ ' %' + ')') 
   
// génération du graphique de synthèse
am4core.ready(function() {

// Themes begin
am4core.useTheme(am4themes_animated);
// Themes end

var chart = am4core.create("graphe_influence", am4charts.PieChart);
chart.hiddenState.properties.opacity = 0; // this creates initial fade-in

chart.data = [
  {
    zone: "influence 20ème Chaise",
    value: inside_20C.features.length,
    labelColor: new am4core.color('blue')
  },
  {
    zone: "influence autres CS",
    value: inside.features.length,
    labelColor: new am4core.color('purple')
  },
  {
    zone: "hors influence",
    value: (layer_adresses.getLayers().length - inside_20C.features.length - inside.features.length),
    labelColor: new am4core.color('green')
  }
];
chart.radius = am4core.percent(50);
chart.innerRadius = am4core.percent(35);
chart.startAngle = 180;
chart.endAngle = 360;  

var series = chart.series.push(new am4charts.PieSeries());
series.dataFields.value = "value";
series.dataFields.category = "zone";

series.slices.template.cornerRadius = 5;
series.slices.template.innerCornerRadius = 5;
series.slices.template.draggable = true;
series.slices.template.inert = true;
series.alignLabels = false;

series.hiddenState.properties.startAngle = 90;
series.hiddenState.properties.endAngle = 90;
series.labels.template.fontSize = 11;
series.labels.template.maxWidth = 60;
series.labels.template.wrap = true;
series.colors.list = [
    new am4core.color('blue'),
    new am4core.color('purple'),
    new am4core.color('green')
];
series.labels.template.text = "{category} {value.percent.formatNumber('#.')}%";
chart.series.getIndex(0).labels.template.propertyFields.fill = "labelColor";

chart.exporting.menu = new am4core.ExportMenu();
chart.exporting.menu.align = "left";
chart.exporting.menu.verticalAlign = "top";

}); // end am4core.ready()

 }
</script>
</p>
<p id="comment_3"></p>	      
<!-- FIN: Exemple 3 -->
	      
   </section>
      </div>
    </div>
  
    <script>
  window.onload = function()
    {   
    	chargement_donnees();
        exemple1();
	exemple2();
	exemple3();
        localStorage.setItem("btn_click", false);
	localStorage.setItem("filtre_final", '');
	localStorage.setItem("rayon_cercles",'750') ;
    }
    
 </script>


  <footer>
      <div class="inner">
       &copy; janvier 2021 <a href="mailto:francois.rigot.fr@gmail.com" target="_blank">François R</a>
      </div>
    </footer>

  </body>
</html>

