<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Adresses des adherents de la 20eme C</title>
    <script src="./javascripts/hull.js"></script>
    <script src="./javascripts/dataGeo.js"></script>
    <script src="./javascripts/fonctions.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-ajax/2.1.0/leaflet.ajax.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script> 
    <script src="https://api.mapbox.com/mapbox.js/plugins/leaflet-geodesy/v0.1.0/leaflet-geodesy.js"></script>
    <link href="//cdn.bootcss.com/noUiSlider/8.5.1/nouislider.min.css" rel="stylesheet">
    <script src="//cdn.bootcss.com/noUiSlider/8.5.1/nouislider.js"></script>
	  
    <script src="./javascripts/qpv_qva.json"></script>
    <script src="./javascripts/IRIS.json"></script>

</head>
<body>
    <header>
      <h3>Public de la 20ème Chaise - Saisons 2018-19 et 2019-2020 </h3>
        <a href="https://www.la20emechaise.org/" class="button">Site internet du centre social</a>
      </div>
    </header>

	<script>
	function Separateur_Milliers(value) {
    	return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
	};
	</script>
	
    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
<p> - extraction de 902 adresses de Noe <br>
    - récupération des coordonnées des adresses via https://adresse.data.gouv.fr/csv <br>
    - on va étudier :  <br>
	- Partie 1 : la localisation des adresses par rapport aux quartiers prioritaires de la ville,  <br>
	aux quartiers de veille active et aux anciens quartiers de veille  <br>
	- Partie 2 : la répartition des adresses selon le temps de trajet à la 20ème Chaise <br>
	- Partie 3 : la répartition des adresses dans les IRIS et les zones d'influence des autres centres sociaux parisiens
</p>


<form id="filtre">
<fieldset>
  <legend>Vous pouvez filtrer les données selon les critères suivants :</legend>
<div>
<input type="checkbox" id ="filtre_ASL" name="type_filtre"/>
<label for="filtre_ASL">ASL</label>
</div>
<div style="display: none;">
<input type="radio" id ="asl1" name="asl" value="asl1"/ checked>
<label for="asl1">pas de filtre ASL</label>
</div>
<div style="display: none;">
<input type="radio" id ="asl2" name="asl" value="asl2"/>
<label for="asl2">inscrits uniquement aux ASL</label>
</div>
<div>
<input type="checkbox" id ="filtre_benevole" name="type_filtre"/>
<label for="filtre_benevole">Bénévoles</label>
</div>
<div style="display: none;">
<input type="radio" id ="bene1" name="bene" value="bene1"/ checked>
<label for="asl1">pas de filtre bénévole</label>
</div>
<div style="display: none;">
<input type="radio" id ="bene2" name="bene" value="bene2"/>
<label for="asl2">bénévole sur au moins un type d'activité</label>
</div>
<div>
<input type="checkbox" id ="filtre_type_act" name="type_filtre"/>
<label for="filtre_type_act">Types d'activités auxquelles le public s'est inscrit</label>
</div>
<!--
<div id="type_act"></div>
//-->
<input type="checkbox" id ="filtre_nb_act" name="type_filtre"/>
<label for="filtre_nb_act">Nombre d'activités auxquelles le public s'est inscrit</label>
</div>
</fieldset>
</form>
<div>	
<input type="button" id = "bouton_filtre_asl" name="bout" value="Générer l'analyse" onClick="test()"
       style="height:50px; width:50%; margin-left:25%; margin-right:25%;margin-top: 0.5cm;margin-bottom: 0.5cm; background-color:#B0C4DE" />
</div>

<script>
for (let i=0 ; i < document.getElementsByName('asl').length ; i++)
{document.getElementsByName('asl')[i].style.display = "none" ;
 document.getElementsByName('asl')[i].label.style.display = "none" ;};
</script>      
	   
<script>
/*
    var range = document.getElementById('type_act');

    noUiSlider.create(range, {
        start: [ 20, 80 ], // Handle start position
        step: 10, // Slider moves in increments of '10'
        margin: 20, // Handles must be more than '20' apart
        connect: true, // Display a colored bar between the handles
        direction: 'rtl', // Put '0' at the bottom of the slider
        orientation: 'vertical', // Orient the slider vertically
        behaviour: 'tap-drag', // Move handle on tap, bar is draggable
        range: { // Slider can select '0' to '100'
            'min': 0,
            'max': 100
        },
        pips: { // Show a scale with the slider
            mode: 'steps',
            density: 2
        }
    });

    var valueInput = document.getElementById('value-input'),
            valueSpan = document.getElementById('value-span');

    // When the slider value changes, update the input and span
    range.noUiSlider.on('update', function( values, handle ) {
        if ( handle ) {
            valueInput.value = values[handle];
        } else {
            valueSpan.innerHTML = values[handle];
        }
    });

    // When the input changes, set the slider value
    valueInput.addEventListener('change', function(){
        range.noUiSlider.set([null, this.value]);
    });
*/
</script>

<script>
var tableau_sortie = [] ;
	
function test() {
document.getElementById('bouton_filtre_asl').value = "Génération de l'analyse en cours..." ;
document.getElementById('bouton_filtre_asl').style.backgroundColor = "#FF8C00" ;
localStorage.setItem("btn_click", true) ;
if (document.getElementById('asl2').checked)
{
localStorage.setItem("filtre_ASL", true) ;
}
window.location.reload();
};
     
</script>

<script>
function chargement_donnees()
{
// on gère le filtrage des données en amont de tous les exemples... si l'envoi de vient pas du bouton
if (JSON.parse(localStorage.getItem("btn_click")) === false)
	{  
tableau_sortie = data.filter(function(element) {
    return (element.asl >= 0);});
	}
	else
	{
 console.log(localStorage.getItem("filtre_ASL"));
// on place des filtres fonction de ce qui a été sélectionné par l'utilisateur
	if (JSON.parse(localStorage.getItem("filtre_ASL")) === true)
		{tableau_sortie = data.filter(function(element) {
    		return (element.asl >= 1);});
		}
		else
		{tableau_sortie = data.filter(function(element) {
    		return (element.asl >= 0);});
		}
	}
}
	
</script>

<!-- Exemple 1 -->
<h3><a name="ex1" class="anchor" ><span class="octicon octicon-link"></span>QPV, QVA et AQV</a></h3>

<p> - récupération des polygones définissant les quartiers prioritaires via une source de type GeoJSON <br>
    - recherche des adresses relevant d'un NQPV (frontière noire), QVA (frontière jaune) ou AQV (frontière violette) via fonction turf.js PointsWithinPolygon <br>
    - survoler les quartiers prioritaires pour voir apparaître le nom de la zone
</p>

<p>
  <div id="map_1" style="width: 840px; height: 560px"></div>
  <script>
	  
 function exemple1() {
    var map_1 = L.map('map_1').setView([48.864891,2.389828], 15);
  	 

    tableau_sortie.map( adresse => {
    let properties = {
   "lng": adresse.lng,
   "lat": adresse.lat
    };
    return properties;
    });
	 
    var PS = tableau_sortie;
   
    //var Res_Max = Math.max.apply(null,data.map(function(o){return o.duree_pied;}));
    //var Res_Min = Math.min.apply(null,data.map(function(o){return o.duree_pied;}));
  
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map_1);
  
  var Layer_NQPV = L.geoJson(geojsonFeature,  {filter : function(feature) {
        return feature.properties.c_nat_qpv == 'NQPV'}, style : function(feature) {
		return {color: 'black', weight: 2.0, opacity : 0.7, fillOpacity : 0.2}}}
);

  var Layer_QVA = L.geoJson(geojsonFeature,  {filter : function(feature) {
        return feature.properties.c_nat_qpv == 'QVA'}, style : function(feature) {
		return {color: 'yellow', weight : 2.0, opacity : 0.7, fillOpacity : 0.2}}}
);

  var Layer_AQV = L.geoJson(geojsonFeature,  {filter : function(feature) {
        return feature.properties.c_nat_qpv == 'AQV'}, style : function(feature) {
		return {color: 'purple', weight : 2.0, opacity : 0.7, fillOpacity : 0.2}}}
);
  
 Layer_NQPV.addTo(map_1);
 Layer_QVA.addTo(map_1);
 Layer_AQV.addTo(map_1);

map_1.eachLayer(function (layer) {
    // on exclut le layer du fond de carte via un contrôle
    if(layer.hasOwnProperty('feature'))
    {
     layer.bindPopup('<h3>'+layer.feature.properties.c_nat_qpv + ' : ' + layer.feature.properties.l_nqpv + '</h3>');
     layer.on('mouseover', function (e) {this.openPopup();});
     layer.on('mouseout', function (e) {this.closePopup();});
    }
                                   });


// on crée un array avec toutes les adresses source au format turf
var adresses_turf = [];
PS.forEach(function(element)
{adresses_turf.push([element.lng, element.lat]);}
)

// on passe à la recherche d'intersection des adresses avec les zones prioritaire
// et à la création des points de couleur dépendant du résultat

  var layer_adresses_NQPV = L.layerGroup().addTo(map_1);
  var layer_adresses_QVA = L.layerGroup().addTo(map_1);
  var layer_adresses_AQV = L.layerGroup().addTo(map_1);

function inside(points,zone)
{return turf.pointsWithinPolygon(
 turf.points(points), 
 zone.toGeoJSON()
  );}
	 
// on génère dans un premier temps tous les marqueurs qu'on recouvrera ensuite selon les zones le cas échéant
PS.forEach(function(latlng){
        L.circleMarker(latlng, {radius: 2, color : 'blue'}).addTo(map_1);
                     }
	           );
   // var markers_adresses = {'markers': layer_adresses};
   // L.control.layers(null, markers_adresses).addTo(map_1);

  
var adresses_NQPV = inside(adresses_turf,Layer_NQPV);

for (let i=0 ; i < adresses_NQPV.features.length; i++)
{
var coords = [];
coords[0] = adresses_NQPV.features[i].geometry.coordinates[1];
coords[1] = adresses_NQPV.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'black'}).addTo(map_1);
};

var adresses_QVA = inside(adresses_turf,Layer_QVA);

for (let i=0 ; i < adresses_QVA.features.length; i++)
{
var coords = [];
coords[0] = adresses_QVA.features[i].geometry.coordinates[1];
coords[1] = adresses_QVA.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'yellow'}).addTo(map_1);
};

var adresses_AQV = inside(adresses_turf,Layer_AQV);

for (let i=0 ; i < adresses_AQV.features.length; i++)
{
var coords = [];
coords[0] = adresses_AQV.features[i].geometry.coordinates[1];
coords[1] = adresses_AQV.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'purple'}).addTo(map_1);
};

 document.getElementById("comment_1").innerHTML = adresses_NQPV.features.length +
	 ' adresses relèvent d\'un quartier NQPV (en noir).' + '<br/>' +
	 adresses_QVA.features.length +
	 ' adresses relèvent d\'un quartier QVA (en jaune).' + '<br/>' +
	 adresses_AQV.features.length +
	 ' adresses relèvent d\'un quartier AQV (en violet).' + '<br/>'+
	 (adresses_turf.length - adresses_NQPV.features.length
	- adresses_QVA.features.length - adresses_AQV.features.length) + ' n\'en relèvent pas (en bleu).'


 }
</script>
</p>
<p id="comment_1"></p>	      
<!-- FIN: Exemple 1 -->

<!-- Exemple 2 -->
<h3><a name="ex2" class="anchor" ><span class="octicon octicon-link"></span>Temps de trajet à pied</a></h3>

<p> - récupération des temps de trajet et distance (à pied, en voiture, en transports en commun) <br>
    à la 20ème Chaise par Google Map API <br>
    - détermination des enveloppes convexes(-concaves) par algorithme externe
</p>
	      
	      
<p>
  <div id="map_2" style="width: 840px; height: 560px"></div>
  <script>
 function exemple2() {
    var map_2 = L.map('map_2').setView([48.864891,2.389828], 15);
	 
    var bornes = [0,5,10,15,30,10000];
    var key = 'duree_pieds';

    filtrage_num(tableau_sortie,key);

    decoupe(filtre_num,'duree_pieds', bornes);
    
    tableau_filtre.forEach(function(element){
    element.map( adresse => {
    let properties = {
   "lng": adresse.lng,
   "lat": adresse.lat
    };
    return properties;
    });
    });
    
	 
    var PS = tableau_filtre;
   
    //var Res_Max = Math.max.apply(null,data.map(function(o){return o.duree_pied;}));
    //var Res_Min = Math.min.apply(null,data.map(function(o){return o.duree_pied;}));
  
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map_2);
    
    var points = new Array();
    var poly = new Array();
    var surface = new Array();
    var color = ['blue','green','yellow','orange','red'];
    var color_fr = ['bleue','verte','jaune','orange','rouge',];
    var convexite = [1.000,1.000,1.000,1.000,1.000];
	 
    PS.forEach(function(element){
    element.forEach(function(latlng) {
        L.circleMarker(latlng, {radius: 2, color : color[PS.indexOf(element)]}).addTo(map_2);
    });
    points[points.length]= hull(element, convexite[points.length], ['.lng', '.lat']);
    
    var points_poly = [];
    
    for (let i = 0 ; i < points.length  ; i++) {
    points_poly[i] = points[points.length - i - 1];
    };
      
    poly[poly.length] = L.polygon(points_poly, {weight: 2, color : color[poly.length], fillopacity : 0.9});
    surface[surface.length] = L.GeometryUtil.geodesicArea(poly[surface.length].getLatLngs()[0]);
    });
	 
// on insère les polygones dans le sens inverse pour avoir une frontière intérieure de la bonne couleur
    for (let i = points.length-1 ; i >= 0  ; i--) {
    poly[i].addTo(map_2);
    };
    
    color_fr.forEach(function(element){
    document.getElementById("comment_2").innerHTML = document.getElementById("comment_2").innerHTML + ' La surface ' + color_fr[color_fr.indexOf(element)]
	    + ( (color_fr.indexOf(element) < color_fr.length - 1) ? ' (moins de ' + bornes[color_fr.indexOf(element)+1] : ' (plus de ' + bornes[color_fr.indexOf(element)])  + ' minutes de la 20ème Chaise) a une superficie de ' +
	    Separateur_Milliers(Math.round(surface[color_fr.indexOf(element)])) +' mètres carrés' + ' et contient ' + PS[color_fr.indexOf(element)].length + ' adresses.'
	    + '<br/>';
    });
   
	 
  }
  </script>
</p>
<p id="comment_2"></p>
<!-- FIN: Exemple 2 -->

<!-- Exemple 3 -->
<h3><a name="ex3" class="anchor" ><span class="octicon octicon-link"></span>IRIS et zones d'influence des centres sociaux parisiens</a></h3>

<p> - récupération des polygones définissant les IRIS via une source de type GeoJSON <br>
    - on exclut les adresses relevant de la zone de première influence de la 20ème Chaise (liste d'IRIS) (zone en fond bleu)  <br>
    - les zones d'influence des centres sociaux parisiens sont définies par un rayon de 750 mètres <br>
    - la réunion des cercles d'influence apparaît en mauve ainsi que les points correspondants <br>
    - recherche des adresses relevant d'une zone d'influence des autres CS via fonction turf.js PointsWithinPolygon <br>
    - survoler les zones d'IRIS pour voir apparaître le numéro et le nom de l'IRIS
</p>

<p>
  <div id="map_3" style="width: 840px; height: 560px"></div>
  <script>
 function exemple3() {
    var map_3 = L.map('map_3').setView([48.864891,2.389828], 15);
    // var tableau_sortie = data;
  
    tableau_sortie.map( adresse => {
    let properties = {
   "lng": adresse.lng,
   "lat": adresse.lat
    };
    return properties;
    });
	 
    var PS = tableau_sortie;
  
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map_3);
 
    var layer_adresses = L.layerGroup().addTo(map_3);
    PS.forEach(
    function(latlng) {
           layer_adresses.addLayer(L.circleMarker(latlng, {radius: 2, color : 'green'}).addTo(map_3));
    });
    var markers_adresses = {'markers': layer_adresses};
   // L.control.layers(null, markers_adresses).addTo(map_3);

 
    
   
   var PS = centres_sociaux;
 
    var layer_adresses_CS = L.layerGroup().addTo(map_3);

// fonction qui génère l'union de polygones
function unify(polyList,color) {
  for (var i = 0; i < polyList.length; ++i) {
    if (i == 0) {
      var unionTemp = polyList[i].toGeoJSON();
    } else {
      unionTemp = turf.union(unionTemp, polyList[i].toGeoJSON());
    }
  }
  return L.geoJson(unionTemp, {style: {color: color, weight: 1.0, opacity : 0.8, fill : true, fillColor : color , fillOpacity : 0.2}});
}


    var layer_cercles_CS = L.layerGroup().addTo(map_3);
    var radius = 750
    var opts = {parts: 144, fill : 'blue' , fillcolor : 'blue', fillOpacity : 0.9};

var Layer_ZI_20C = L.geoJson(iris, {filter: Filtre_influence_20C, style:  {color: 'black',weight: 1.5, opacity : 0.7, fill : true, fillColor : 'orange', fillOpacity : 0.5}}).addTo(map_3);
	 
function Filtre_influence_20C(feature) {
  if ((feature.properties.C_IR >= 751207906 && feature.properties.C_IR <= 751207910)) return true
}
var ZI_20C = unify(Layer_ZI_20C.getLayers(),'blue')
Layer_ZI_20C.clearLayers();
ZI_20C.addTo(Layer_ZI_20C);

	 
    PS.forEach(
    function(element) {
	if ( element.nom_centre_social != 'La 20eme Chaise') {
        layer_adresses_CS.addLayer(L.circleMarker([element.lat, element.lng], {radius: 4, color : 'red'}).bindTooltip(element.nom_centre_social,{permanent: true, opacity: 0.5, fillcolor : 'yellow'}).addTo(map_3));
	}
    });

// on crée le layer des cercles d'influence des autres CS
layer_adresses_CS.eachLayer(function(layer) {
  var Test = LGeo.circle(layer.getLatLng(), radius, opts);
 var poly = turf.difference(turf.polygon(Test.toGeoJSON().geometry.coordinates),turf.polygon(ZI_20C.toGeoJSON().features[0].geometry.coordinates)) ;
// on doit gérer le cas où la surface différence est un polygone à trou(s) !!
var lng_lat_poly = [];
for (i=0 ; i < poly.geometry.coordinates.length ; i++)
{var lng_lat_tmp = [];
 // on doit inverser les coordonnées de poly issue de turf
 for (j=0 ; j < poly.geometry.coordinates[i].length ; j++)
 {
var lng_lat = [poly.geometry.coordinates[i][j][1], poly.geometry.coordinates[i][j][0]];
lng_lat_tmp.push(lng_lat);
}
lng_lat_poly[i] = lng_lat_tmp;
}
 var cercle_mange = new L.Polygon(lng_lat_poly, {style: {weight: 5.0, color : 'black',  opacity : 0.8, fill : true, fillColor : 'black', fillOpacity : 1.0}});
cercle_mange.addTo(layer_cercles_CS) ;
});

	 
// on crée la zone unique réunion des cercles pour faciliter le calcul des adresses en faisant partie
// on prend la différence avec ces cercles et la zone d'influence de la 20ème Chaise
 var circleUnion = unify(layer_cercles_CS.getLayers(),'purple');
 layer_cercles_CS.clearLayers();
 circleUnion.addTo(layer_cercles_CS);

	 
//var poly = turf.difference(layer_cercles_CS[0].toGeoJSON(),ZI_20C.toGeoJSON()).addTo(map_3) ;
// console.log(poly);
		 

// on recherche les adresses dans la zone globale circleUnion
	 
var points_turf = [];
layer_adresses.eachLayer(function(element)
{
var lnglat = [element._latlng.lng, element._latlng.lat];
points_turf.push(lnglat);
}
)


// identification des points dans zone 20eme Chaise
var inside_20C = 
turf.pointsWithinPolygon(
 turf.points(points_turf), 
 ZI_20C.toGeoJSON()
  );
  
for (let i=0 ; i < inside_20C.features.length; i++)
{
var coords = [];
coords[0] = inside_20C.features[i].geometry.coordinates[1];
coords[1] = inside_20C.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'blue'}).addTo(map_3);
};

// identification des points hors zone 20eme Chaise dans zone influence autres CS
var inside = 
turf.pointsWithinPolygon(
 turf.points(points_turf), 
 circleUnion.toGeoJSON()
  );
  
for (let i=0 ; i < inside.features.length; i++)
{
var coords = [];
coords[0] = inside.features[i].geometry.coordinates[1];
coords[1] = inside.features[i].geometry.coordinates[0];	
L.circleMarker(coords, {radius: 2, color : 'purple'}).addTo(map_3);
};

 var Layer_IRIS = L.geoJson(iris, { style:  {color: 'black', weight: 1.0, opacity : 0.7, fillColor : 'white', fillOpacity : 0.0}}).bindTooltip(function (layer) {
    return 'IRIS' + '<br/>' + layer.feature.properties.C_IR + ' : ' + layer.feature.properties.L_IR; //merely sets the tooltip text
 }, {permanent: false, opacity: 0.8}  //then add your options
 ).addTo(map_3);


 document.getElementById("comment_3").innerHTML = inside_20C.features.length +
	 ' sont dans la zone d\'influence de la 20ème Chaise.' + '<br/>' +
	 inside.features.length +
	 ' sont dans une zone d\'influence d\'un autre centre social.' + '<br/>' +
	 (layer_adresses.getLayers().length - inside_20C.features.length - inside.features.length) + ' sont hors zones d\'influence.'
   
  
    // var markers_adresses_CS = {'markers': layer_adresses_CS};
    // L.control.layers(null, markers_adresses_CS).addTo(map_3);

    //layer_adresses_CS.eachLayer(function(layer)
    // {console.log(layer.getTooltip()._content.replace('Centre social<br/>',''));});


 }
</script>
</p>
<p id="comment_3"></p>	      
<!-- FIN: Exemple 3 -->
	      
   </section>
      </div>
    </div>
  
    <script>
  window.onload = function()
    {
    	chargement_donnees();
        exemple1();
	exemple2();
	exemple3();
        localStorage.setItem("btn_click", false);
	localStorage.setItem("filtre_ASL", false);
    }
    
 </script>


  <footer>
      <div class="inner">
       &copy; janvier 2021 <a href="mailto:francois.rigot.fr@gmail.com" target="_blank">François R</a>
      </div>
    </footer>

  </body>
</html>

